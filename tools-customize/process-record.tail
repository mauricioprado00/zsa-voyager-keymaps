

uint16_t virtual_shift = 0;
bool bspc_shift_held = false;
uint16_t bspc_shift_timer = 0;
bool bspc_shift_sent_shift = false;
uint16_t bspc_shift_repeat_timer = 0;

bool scln_rsft_held = false;
uint16_t scln_rsft_timer = 0;
bool scln_rsft_sent_shift = false;
uint16_t scln_rsft_repeat_timer = 0;
bool scln_rsft_mod_shift = false;

bool process_bspc_shift(uint16_t keycode, keyrecord_t *record) {
  if (keycode == BSPC_SHIFT) {
    if (record->event.pressed) {
        bspc_shift_held = true;
        bspc_shift_sent_shift = false;
        bspc_shift_timer = timer_read();
        if (SCLN_RSFT_REPEAT_ON_HOLD) {
          bspc_shift_repeat_timer = bspc_shift_timer;
        }
    } else {
        if (bspc_shift_sent_shift) {
            unregister_code(KC_LSFT);
            virtual_shift--;
        } else {
            tap_code(KC_BSPC);
        }
        bspc_shift_held = false;
    }
    return false;
  }

  if (record->event.pressed && bspc_shift_held && !bspc_shift_sent_shift) {
      // Trigger shift behavior
      register_code(KC_LSFT);
      virtual_shift++;
      bspc_shift_sent_shift = true;
  }

  return true;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  bool result = true;
  bool mod_shift = get_mods() & MOD_MASK_SHIFT;
  result  = process_bspc_shift(keycode, record) && result;
  switch (keycode) {

    case DUAL_FUNC_0:
      if (record->tap.count > 0) {
        if (record->event.pressed) {
          register_code16(KC_EQUAL);
        } else {
          unregister_code16(KC_EQUAL);
        }
      } else {
        if (record->event.pressed) {
          register_code16(KC_ESCAPE);
        } else {
          unregister_code16(KC_ESCAPE);
        }
      }
      return false;
    case RGB_SLD:
      if (record->event.pressed) {
        rgblight_mode(1);
      }
      return false;
    case HSV_0_255_255:
      if (record->event.pressed) {
        rgblight_mode(1);
        rgblight_sethsv(0,255,255);
      }
      return false;
    case HSV_74_255_255:
      if (record->event.pressed) {
        rgblight_mode(1);
        rgblight_sethsv(74,255,255);
      }
      return false;
    case HSV_169_255_255:
      if (record->event.pressed) {
        rgblight_mode(1);
        rgblight_sethsv(169,255,255);
      }
      return false;
    case SCLN_RSFT:
      if (record->event.pressed) {
        scln_rsft_held = true;
        scln_rsft_sent_shift = false;
        scln_rsft_timer = timer_read();
        if (SCLN_RSFT_REPEAT_ON_HOLD) {
          scln_rsft_repeat_timer = scln_rsft_timer;
        }
        scln_rsft_mod_shift = virtual_shift;
      } else {
        if (scln_rsft_sent_shift) {
          unregister_code(KC_RSFT);
          virtual_shift--;
        } else {
          if (!mod_shift && scln_rsft_mod_shift) {
            tap_code16(S(SCLN_RSFT_TAP_CODE));
          } else {
            tap_code(SCLN_RSFT_TAP_CODE);
          }
        }
        scln_rsft_held = false;
      }
      return false;

    default:
      // if another key is pressed while SCLN_RSFT is held, trigger shift
      if (record->event.pressed && scln_rsft_held && !scln_rsft_sent_shift) {
        register_code(KC_RSFT);
        virtual_shift++;
        scln_rsft_sent_shift = true;
      }

      return result;
  }
  return result;
}

void matrix_scan_user(void) {
  if (BSPC_SHIFT_REPEAT_ON_HOLD) {
    if (bspc_shift_held && !bspc_shift_sent_shift) {
      if (timer_elapsed(bspc_shift_timer) > REPEAT_DELAY) {
        if (timer_elapsed(bspc_shift_repeat_timer) > REPEAT_INTERVAL) {
          tap_code(KC_BSPC);
          bspc_shift_repeat_timer = timer_read();
        }
      }
    }
  }

  if (SCLN_RSFT_REPEAT_ON_HOLD) {
    if (scln_rsft_held && !scln_rsft_sent_shift) {
      if (timer_elapsed(scln_rsft_timer) > REPEAT_DELAY) {
        if (timer_elapsed(scln_rsft_repeat_timer) > REPEAT_INTERVAL) {
          tap_code(SCLN_RSFT_TAP_CODE);
          scln_rsft_repeat_timer = timer_read();
        }
      }
    }
  }
}
